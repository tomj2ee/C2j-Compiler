<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">

   <link rel="stylesheet" href="main.css" />
  <style type="text/css" > </style>
 <title> java字符串应用之表达式解析器</title>
 <body> java字符串应用之表达式解析器</body>
<div class="post"> 
 <h1 class="postTitle"> <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/csguo/p/7614902.html"> <span role="heading" aria-level="2">java字符串应用之表达式解析器</span> </a> </h1> 
 <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html"> 
  <p>&nbsp;一、表达式的组成<br>&nbsp;&nbsp;&nbsp; 1、数字<br>&nbsp;&nbsp;&nbsp; 2、运算符：+ - / * ^ % =<br>&nbsp;&nbsp;&nbsp; 3、圆括号<br>&nbsp;&nbsp;&nbsp; 4、变量<br>二、运算符优先级<br>&nbsp;&nbsp;&nbsp; 由高到低分别为：+-(正负号)、^、*/%、+-、=<br>&nbsp;&nbsp;&nbsp; 优先级相等的运算符按照从左到右的顺序计算<br>三、关键技术点<br>&nbsp;&nbsp;&nbsp; 1、确定运算的优先级，从高到低分别为：原子元素表达式，包括数字和变量；括号表达式；一元表达式，取数的负数；指数表达式；乘、除、取模表达式；加、减表达式；赋值表达式。<br>&nbsp;&nbsp;&nbsp; 2、对于每一级别的运算，都由一个方法实现，在方法中先完成比自己高一级别的运算，再处理本级别的运算。因此，在计算整个表达式的主方法中，只需要调用最低级别的运算的实现方法即可。<br>&nbsp;&nbsp;&nbsp; 3、确定表达式中的分隔符，（+、-、*、/、%、^、=、(、)、）。利用这些分隔符将表达式分成多段，每一段叫做一个token，分隔符也算token。<br>&nbsp;&nbsp;&nbsp; 4、用长度为26的int数组vars存储变量的值。<br>&nbsp;&nbsp;&nbsp; 5、Character的isWhitespace方法判断字符是否为空白符，用于去掉表达式中的空白符。<br>&nbsp;&nbsp;&nbsp; 6、Character的isLetter方法判断字符是否为字母，用于提取表达式中的变量<br>&nbsp;&nbsp;&nbsp; 7、Character的isDigit方法判断字符是否为数字，用于获取表达式中的数字<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>四、演示实例</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>/** *//**<br>&nbsp;* 文件名ExpressionParser.java<br>&nbsp;*/<br>package book.oo.String;</p> 
  <p>/** *//**<br>&nbsp;* 表达式解析器<br>&nbsp;* @author joe<br>&nbsp;*<br>&nbsp;*/<br>public class ExpressionParser ...{<br>&nbsp;&nbsp;&nbsp; //4种标记类型<br>&nbsp;&nbsp;&nbsp; public static final int NONE_TOKEN = 0;&nbsp;&nbsp;&nbsp; //标记为空或者结束符<br>&nbsp;&nbsp;&nbsp; public static final int DELIMITER_TOKEN = 1;&nbsp;&nbsp;&nbsp; //标记为分隔符<br>&nbsp;&nbsp;&nbsp; public static final int VARIABLE_TOKEN = 2;&nbsp;&nbsp;&nbsp; //标记为变量<br>&nbsp;&nbsp;&nbsp; public static final int NUMBER_TOKEN = 3;&nbsp;&nbsp;&nbsp; //标记为数字<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; //4种错误类型<br>&nbsp;&nbsp;&nbsp; public static final int SYNTAX_ERROR = 0;&nbsp;&nbsp;&nbsp; //语法错误<br>&nbsp;&nbsp;&nbsp; public static final int UNBALPARENS_ERROR = 1;&nbsp;&nbsp;&nbsp; //括号没有结束错误<br>&nbsp;&nbsp;&nbsp; public static final int NOEXP_ERROR = 2;&nbsp;&nbsp;&nbsp; //表达式为空错误<br>&nbsp;&nbsp;&nbsp; public static final int DIVBYZERO_ERROR = 3;&nbsp;&nbsp;&nbsp; //被0除错误<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; //针对4种错误类型定义的4个错误提示<br>&nbsp;&nbsp;&nbsp; public static final String[] ERROR_MESSAGES = ...{"Syntax Error", "Unbalanced " +<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Parentheses", "No Expression Present", "Division by Zero"};<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; //表达式的结束标记<br>&nbsp;&nbsp;&nbsp; public static final String EOE = ""/0";<br>&nbsp;<br>&nbsp;private String exp; //表达式字符串<br>&nbsp;private int expIndex; //解析器当前指针在表达式中的位置<br>&nbsp;private String token; //解析器当前处理的标记<br>&nbsp;private int tokenType; //解析器当前处理的标记类型<br>&nbsp;private double[] vars = new double[26]; //变量数组<br>&nbsp;/**<br>&nbsp; *&nbsp;<br>&nbsp; */<br>&nbsp;public ExpressionParser() {<br>&nbsp;}<br>&nbsp;<br>&nbsp;/**<br>&nbsp; * 解析一个表达式，返回表达式的值<br>&nbsp; */<br>&nbsp;public double evaluate(String expStr) throws Exception {<br>&nbsp; double result;<br>&nbsp; this.exp = expStr;<br>&nbsp; this.expIndex = 0;<br>&nbsp;&nbsp;<br>&nbsp; //获取第一个标记<br>&nbsp; this.getToken();<br>&nbsp; if (this.token.equals(EOE)) {<br>&nbsp;&nbsp; //没有表达式异常<br>&nbsp;&nbsp; this.handleError(NOEXP_ERROR);<br>&nbsp; }<br>&nbsp;&nbsp;<br>&nbsp; result = this.parseAssign(); //处理赋值语句<br>&nbsp; //处理完赋值语句，应该就是表达式结束符，如果不是，则返回异常<br>&nbsp; if(!this.token.equals(EOE)) {<br>&nbsp;&nbsp; this.handleError(SYNTAX_ERROR);<br>&nbsp; }<br>&nbsp; return result;<br>&nbsp;}<br>&nbsp;<br>&nbsp;/**<br>&nbsp; * 处理赋值语句<br>&nbsp; */<br>&nbsp;public double parseAssign() throws Exception {<br>&nbsp; double result; //结果<br>&nbsp; int varIndex; //变量下标<br>&nbsp; String oldToken; //旧标记<br>&nbsp; int oldTokenType; //旧标记的类型<br>&nbsp;&nbsp;<br>&nbsp; //如果标记类型是变量<br>&nbsp; if (this.tokenType == VARIABLE_TOKEN) {<br>&nbsp;&nbsp; //保存当前标记<br>&nbsp;&nbsp; oldToken = new String(this.token);<br>&nbsp;&nbsp; oldTokenType = this.tokenType;<br>&nbsp;&nbsp; //取得变量的索引，本解析器只支持一个字母的变量<br>&nbsp;&nbsp; //如果用户的变量字母长度大于1，则取第一个字母当作变量<br>&nbsp;&nbsp; varIndex = Character.toUpperCase(this.token.charAt(0)) - ''A'';<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; //获得下一个标记<br>&nbsp;&nbsp; this.getToken();<br>&nbsp;&nbsp; //如果当前标记不是等号＝<br>&nbsp;&nbsp; if(!this.token.equals("=")) {<br>&nbsp;&nbsp;&nbsp; this.putBack(); //回滚<br>&nbsp;&nbsp;&nbsp; //不是一个赋值语句，将标记恢复到上一个标记<br>&nbsp;&nbsp;&nbsp; this.token = new String(oldToken);<br>&nbsp;&nbsp;&nbsp; this.tokenType = oldTokenType;<br>&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp; //如果当前标记是等号＝，即给变量赋值，形式如：a = 3 + 5;<br>&nbsp;&nbsp;&nbsp; //则计算等号后面表达式的值，然后再将得到的值赋给变量<br>&nbsp;&nbsp;&nbsp; this.getToken();<br>&nbsp;&nbsp;&nbsp; //因为加减法的优先级最低，所以计算加减法表达式<br>&nbsp;&nbsp;&nbsp; result = this.parseAddOrSub();<br>&nbsp;&nbsp;&nbsp; //将表达式的值赋给变量，并存在实例变量vars中<br>&nbsp;&nbsp;&nbsp; this.vars[varIndex] = result;<br>&nbsp;&nbsp;&nbsp; return result;<br>&nbsp;&nbsp; }<br>&nbsp; }<br>&nbsp; //如果当前标记类型不是变量，或者不是赋值语句，则用加减法计算表达式的值<br>&nbsp; return this.parseAddOrSub();<br>&nbsp;}<br>&nbsp;<br>&nbsp;/** 计算加减法表达式 */<br>&nbsp;private double parseAddOrSub() throws Exception {<br>&nbsp; char op; //运算符<br>&nbsp; double result; //结果<br>&nbsp; double partialResult; //子表达式的结果<br>&nbsp;&nbsp;<br>&nbsp; result = this.pareseMulOrDiv(); //用乘除法计算当前表达式的值<br>&nbsp; //如果当前标记的第一个字母是加减号，则继续进行加减运算<br>&nbsp; while ((op = this.token.charAt(0)) == ''+'' || op == ''-'') {<br>&nbsp;&nbsp; this.getToken(); //取下一个标记<br>&nbsp;&nbsp; //用乘除法计算当前子表达式的值<br>&nbsp;&nbsp; partialResult = this.pareseMulOrDiv();<br>&nbsp;&nbsp; switch(op) {<br>&nbsp;&nbsp; case ''-'':<br>&nbsp;&nbsp;&nbsp; //如果是减法，则用已处理的子表达式的值减去当前子表达式的值<br>&nbsp;&nbsp;&nbsp; result = result - partialResult;<br>&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp; case ''+'':<br>&nbsp;&nbsp;&nbsp; //如果是加法，用已处理的子表达式的值加上当前子表达式的值<br>&nbsp;&nbsp;&nbsp; result = result + partialResult;<br>&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp; }<br>&nbsp; }<br>&nbsp; return result;<br>&nbsp;}<br>&nbsp;/**<br>&nbsp; * 计算乘除法表达式，包括取模运算<br>&nbsp; */<br>&nbsp;private double pareseMulOrDiv() throws Exception {<br>&nbsp; char op; //运算符<br>&nbsp; double result; //结果<br>&nbsp; double partialResult; //子表达式结果<br>&nbsp; //用指数运算计算当前子表达式的值<br>&nbsp; result = this.parseExponent();<br>&nbsp; //如果当前标记的第一个字母是乘、除或者取模运算，则继续进行乘除法运算<br>&nbsp; while ((op = this.token.charAt(0)) == ''*'' || op == ''/'' || op == ''%'') {<br>&nbsp;&nbsp; this.getToken(); //取下一标记<br>&nbsp;&nbsp; //用指数运算计算当前子表达式的值<br>&nbsp;&nbsp; partialResult = this.parseExponent();<br>&nbsp;&nbsp; switch (op) {<br>&nbsp;&nbsp; case ''*'':<br>&nbsp;&nbsp;&nbsp; //如果是乘法，则用已处理子表达式的值乘以当前子表达式的值<br>&nbsp;&nbsp;&nbsp; result = result * partialResult;<br>&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp; case ''/'':<br>&nbsp;&nbsp;&nbsp; //如果是除法，判断当前字表达式的值是否为0，如果为0，则抛出被0除异常<br>&nbsp;&nbsp;&nbsp; if(partialResult == 0.0) {<br>&nbsp;&nbsp;&nbsp;&nbsp; this.handleError(DIVBYZERO_ERROR);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; //除数不为0，则进行除法运算<br>&nbsp;&nbsp;&nbsp; result = result / partialResult;<br>&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp; case ''%'':<br>&nbsp;&nbsp;&nbsp; //如果是取模运算，也要判断当前子表达式的值是否为0<br>&nbsp;&nbsp;&nbsp; if(partialResult == 0.0) {<br>&nbsp;&nbsp;&nbsp;&nbsp; this.handleError(DIVBYZERO_ERROR);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; result = result % partialResult;<br>&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp; }<br>&nbsp; }<br>&nbsp; return result;<br>&nbsp;}<br>&nbsp;<br>&nbsp;/**<br>&nbsp; * 计算指数表达式<br>&nbsp; */<br>&nbsp;private double parseExponent() throws Exception {<br>&nbsp; double result; //结果<br>&nbsp; double partialResult; //子表达式的值<br>&nbsp; double ex; //指数的底数<br>&nbsp; int t; //指数的幂<br>&nbsp;&nbsp;<br>&nbsp; //用一元运算计算当前子表达式的值（底数）<br>&nbsp; result = this.parseUnaryOperator();<br>&nbsp; //如果当前标记为“^”,则为指数运算<br>&nbsp; if (this.token.equals("^")) {<br>&nbsp;&nbsp; //获取下一标记，即获得指数的幂<br>&nbsp;&nbsp; this.getToken();<br>&nbsp;&nbsp; partialResult = this.parseExponent();<br>&nbsp;&nbsp; ex = result;<br>&nbsp;&nbsp; if(partialResult == 0.0) {<br>&nbsp;&nbsp;&nbsp; //如果指数的幂为0，则指数的值为1<br>&nbsp;&nbsp;&nbsp; result = 1.0;<br>&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp; //否则，指数的值为个数为指数幂的底数相乘的结果<br>&nbsp;&nbsp;&nbsp; for (t = (int) partialResult - 1; t &gt; 0; t--) {<br>&nbsp;&nbsp;&nbsp;&nbsp; result =result * ex;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; }<br>&nbsp; }<br>&nbsp; return result;<br>&nbsp;}<br>&nbsp;<br>&nbsp;/**<br>&nbsp; * 计算一元运算，＋，－，表示正数和负数&nbsp;<br>&nbsp; */<br>&nbsp;private double parseUnaryOperator() throws Exception{<br>&nbsp; double result; //结果<br>&nbsp; String op; //运算符<br>&nbsp; op = "";<br>&nbsp; //如果当前标记类型为分隔符，而且分隔符的值等于+或者-<br>&nbsp; if((this.tokenType == DELIMITER_TOKEN) &amp;&amp; this.token.equals("+") || this.token.equals("-")) {<br>&nbsp;&nbsp; op = this.token;<br>&nbsp;&nbsp; this.getToken();<br>&nbsp; }<br>&nbsp; //用括号运算计算当前子表达式的值<br>&nbsp; result = this.parseBracket();<br>&nbsp; if(op.equals("-")) {<br>&nbsp;&nbsp; //如果运算符为-，则表示负数，将子表达式的值变为负数<br>&nbsp;&nbsp; result = -result;<br>&nbsp; }<br>&nbsp; return result;<br>&nbsp;}<br>&nbsp;<br>&nbsp;/**<br>&nbsp; * 计算括号运算<br>&nbsp; */<br>&nbsp;private double parseBracket() throws Exception {<br>&nbsp; double result; //结果<br>&nbsp; //如果当前标记为左括号，则表示是一个括号运算<br>&nbsp; if (this.token.equals("(")) {<br>&nbsp;&nbsp; this.getToken(); //取下一标记<br>&nbsp;&nbsp; result = this.parseAddOrSub(); //用加减法运算计算子表达式的值<br>&nbsp;&nbsp; //如果当前标记不等于右括号，抛出括号不匹配异常<br>&nbsp;&nbsp; if (!this.token.equals(")")) {<br>&nbsp;&nbsp;&nbsp; this.handleError(UNBALPARENS_ERROR);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; this.getToken(); //否则取下一个标记<br>&nbsp; } else {<br>&nbsp;&nbsp; //如果不是左括号，表示不是一个括号运算，则用原子元素运算计算子表达式值<br>&nbsp;&nbsp; result = this.parseAtomElement();<br>&nbsp; }<br>&nbsp; return result;<br>&nbsp;}<br>&nbsp;<br>&nbsp;/**<br>&nbsp; * 计算原子元素运算，包括变量和数字&nbsp;<br>&nbsp; */<br>&nbsp;private double parseAtomElement() throws Exception {<br>&nbsp; double result = 0.0; //结果<br>&nbsp;&nbsp;<br>&nbsp; switch(this.tokenType) {<br>&nbsp; case NUMBER_TOKEN:<br>&nbsp;&nbsp; //如果当前标记类型为数字<br>&nbsp;&nbsp; try {<br>&nbsp;&nbsp;&nbsp; //将数字的字符串转换成数字值<br>&nbsp;&nbsp;&nbsp; result = Double.parseDouble(this.token);<br>&nbsp;&nbsp; } catch (NumberFormatException exc) {<br>&nbsp;&nbsp;&nbsp; this.handleError(SYNTAX_ERROR);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; this.getToken(); //取下一个标记<br>&nbsp;&nbsp; break;<br>&nbsp; case VARIABLE_TOKEN:<br>&nbsp;&nbsp; //如果当前标记类型是变量，则取变量的值<br>&nbsp;&nbsp; result = this.findVar(token);<br>&nbsp;&nbsp; this.getToken();<br>&nbsp;&nbsp; break;<br>&nbsp; default:<br>&nbsp;&nbsp; this.handleError(SYNTAX_ERROR);<br>&nbsp;&nbsp; break;<br>&nbsp; }<br>&nbsp; return result;<br>&nbsp;}<br>&nbsp;<br>&nbsp;/**<br>&nbsp; * 根据变量名获取变量的值，如果变量名长度大于1，则只取变量的第一个字符&nbsp;<br>&nbsp; */<br>&nbsp;private double findVar(String vname) throws Exception {<br>&nbsp; if (!Character.isLetter(vname.charAt(0))) {<br>&nbsp;&nbsp; this.handleError(SYNTAX_ERROR);<br>&nbsp;&nbsp; return 0.0;<br>&nbsp; }<br>&nbsp; //从实例变量数组vars中取出该变量的值<br>&nbsp; return vars[Character.toUpperCase(vname.charAt(0)) - ''A''];<br>&nbsp;}<br>&nbsp;<br>&nbsp;/**&nbsp;<br>&nbsp; * 回滚，将解析器当前指针往前移到当前标记位置<br>&nbsp; */<br>&nbsp;private void putBack() {<br>&nbsp; if (this.token == EOE) {<br>&nbsp;&nbsp; return;<br>&nbsp; }<br>&nbsp; //解析器当前指针往前移动<br>&nbsp; for (int i = 0; i &lt; this.token.length(); i++ ){<br>&nbsp;&nbsp; this.expIndex--;<br>&nbsp; }<br>&nbsp;}<br>&nbsp;<br>&nbsp;/**<br>&nbsp; * 处理异常情况<br>&nbsp; */<br>&nbsp;private void handleError(int errorType) throws Exception {<br>&nbsp; //遇到异常情况时，根据错误类型，取得异常提示信息，将提示信息封装在异常中抛出<br>&nbsp; throw new Exception(ERROR_MESSAGES[errorType]);<br>&nbsp;}<br>&nbsp;<br>&nbsp;/**<br>&nbsp; * 获取下一个标记<br>&nbsp; */<br>&nbsp;private void getToken() {<br>&nbsp; //设置初始值<br>&nbsp; this.token = "";<br>&nbsp; this.tokenType = NONE_TOKEN;<br>&nbsp;&nbsp;<br>&nbsp; //检查表达式是否结束，如果解析器当前指针已经到达了字符串长度，<br>&nbsp; //则表明表达式已经结束，置当前标记的值为EOE<br>&nbsp; if(this.expIndex == this.exp.length()) {<br>&nbsp;&nbsp; this.token = EOE;<br>&nbsp;&nbsp; return;<br>&nbsp; }<br>&nbsp;&nbsp;<br>&nbsp; //跳过表达式中的空白符<br>&nbsp; while (this.expIndex &lt; this.exp.length()&nbsp;<br>&nbsp;&nbsp;&nbsp; &amp;&amp; Character.isWhitespace(this.exp.charAt(this.expIndex))) {<br>&nbsp;&nbsp; ++this.expIndex;<br>&nbsp; }<br>&nbsp;&nbsp;<br>&nbsp; //再次检查表达式是否结束<br>&nbsp; if (this.expIndex == this.exp.length()) {<br>&nbsp;&nbsp; this.token = EOE;<br>&nbsp;&nbsp; return;<br>&nbsp; }<br>&nbsp;&nbsp;<br>&nbsp; //取得解析器当前指针指向的字符<br>&nbsp; char currentChar = this.exp.charAt(this.expIndex);<br>&nbsp; //如果当前字符是一个分隔符，则认为这是一个分隔符标记<br>&nbsp; //给当前标记和标记类型赋值，并将指针后移<br>&nbsp; if(isDelim(currentChar)) {<br>&nbsp;&nbsp; this.token += currentChar;<br>&nbsp;&nbsp; this.expIndex++;<br>&nbsp;&nbsp; this.tokenType = DELIMITER_TOKEN;<br>&nbsp; } else if (Character.isLetter(currentChar)) {<br>&nbsp;&nbsp; //如果当前字符是一个字母，则认为是一个变量标记<br>&nbsp;&nbsp; //将解析器指针往后移，知道遇到一个分隔符，之间的字符都是变量的组成部分<br>&nbsp;&nbsp; while(!isDelim(currentChar)) {<br>&nbsp;&nbsp;&nbsp; this.token += currentChar;<br>&nbsp;&nbsp;&nbsp; this.expIndex++;<br>&nbsp;&nbsp;&nbsp; if(this.expIndex &gt;= this.exp.length()) {<br>&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp; currentChar = this.exp.charAt(this.expIndex);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; this.tokenType = VARIABLE_TOKEN; //设置标记类型为变量<br>&nbsp; } else if (Character.isDigit(currentChar)) {<br>&nbsp;&nbsp; //如果当前字符是一个数字，则认为当前标记的类型为数字<br>&nbsp;&nbsp; //将解析器指针后移，知道遇到一个分隔符，之间的字符都是该数字的组成部分<br>&nbsp;&nbsp; while(!isDelim(currentChar)) {<br>&nbsp;&nbsp;&nbsp; this.token += currentChar;<br>&nbsp;&nbsp;&nbsp; this.expIndex++;<br>&nbsp;&nbsp;&nbsp; if (this.expIndex &gt;= this.exp.length()) {<br>&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp; currentChar = this.exp.charAt(this.expIndex);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; this.tokenType = NUMBER_TOKEN; //设置标记类型为数字<br>&nbsp; } else {<br>&nbsp;&nbsp; //无法识别的字符，则认为表达式结束<br>&nbsp;&nbsp; this.token = EOE;<br>&nbsp;&nbsp; return;<br>&nbsp; }<br>&nbsp;}<br>&nbsp;<br>&nbsp;/**<br>&nbsp; * 判断一个字符是否为分隔符<br>&nbsp; * 表达式中的字符包括：<br>&nbsp; * 加“＋”、减“－”、乘“*”、除“/”、取模“%”、指数“^”、赋值“＝”、左括号“（”、右括号“）”<br>&nbsp; */<br>&nbsp;private boolean isDelim(char c) {<br>&nbsp; if (("+-*/%^=()".indexOf(c) != -1))<br>&nbsp;&nbsp; return true;<br>&nbsp; return false;<br>&nbsp;}<br>&nbsp;/**<br>&nbsp; * @param args<br>&nbsp; */<br>&nbsp;public static void main(String[] args) throws Exception{<br>&nbsp; ExpressionParser test = new ExpressionParser();<br>&nbsp;&nbsp;<br>&nbsp; String exp1 = "a = 5.0";<br>&nbsp; System.out.println("exp1(/"a = 5.0/") = " + test.evaluate(exp1));<br>&nbsp;&nbsp;<br>&nbsp; String exp2 = "b = 3.0";<br>&nbsp; System.out.println("exp2(/"b = 3.0/") = " + test.evaluate(exp2));<br>&nbsp;&nbsp;<br>&nbsp; String exp3 = "(a + b) * (a - b)";<br>&nbsp; System.out.println("exp3(/"(a + b) * (a - b)/") = " + test.evaluate(exp3));<br>&nbsp;&nbsp;<br>&nbsp; String exp4 = "3*5-4/2";<br>&nbsp; System.out.println("exp4(/"3*5-4/2/") = " + test.evaluate(exp4));<br>&nbsp;&nbsp;<br>&nbsp; String exp5 = "(4-2) * ((a + b) / (a - b))";<br>&nbsp; System.out.println("exp5(/"(4 - 2) * ((a + b) / (a - b))/") = " + test.evaluate(exp5));<br>&nbsp;&nbsp;<br>&nbsp; String exp6 = "5 % 2";<br>&nbsp; System.out.println("exp6(/"5 % 2/") = " + test.evaluate(exp6));<br>&nbsp;&nbsp;<br>&nbsp; String exp7 = "3^2 * 5 + 4";<br>&nbsp; System.out.println("exp7(/"3^2 * 5 + 4/") = " + test.evaluate(exp7));<br>&nbsp;}<br>}<br>&nbsp;</p> 
  <p>输出结果：</p> 
  <p>exp1("a = 5.0") = 5.0<br>exp2("b = 3.0") = 3.0<br>exp3("(a + b) * (a - b)") = 16.0<br>exp4("3*5-4/2") = 13.0<br>exp5("(4 - 2) * ((a + b) / (a - b))") = 8.0<br>exp6("5 % 2") = 1.0<br>exp7("3^2 * 5 + 4") = 49.0</p> 
  <p>五、实例分析<br>&nbsp;&nbsp;&nbsp; 表达式的解析，实际就是一个表达式的分解过程。根据分隔符将表达式分成若干段。然后计算每一段的值，最后都会归结到一个原子表达式。</p> 
  <p><br>文章出处：<a href="http://www.diybl.com/course/3_program/java/javaxl/20071126/87573.html" target="_blank" rel="noopener">http://www.diybl.com/course/3_program/java/javaxl/20071126/87573.html</a></p> 
 </div> 
 <div class="clear"></div> 
 <div id="blog_post_info_block" role="contentinfo"> 
  <div id="blog_post_info"></div> 
  <div class="clear"></div> 
  <div id="post_next_prev"></div> 
 </div> 
 <div class="postDesc">
  posted on <span id="post-date">2017-09-30 14:34</span>&nbsp; <a href="https://www.cnblogs.com/csguo/">csguo</a>&nbsp; 阅读(<span id="post_view_count">7455</span>)&nbsp; 评论(<span id="post_comment_count">0</span>)&nbsp; <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7614902" rel="nofollow">编辑</a>&nbsp; <a href="javascript:void(0)" onclick="AddToWz(7614902);return false;">收藏</a>&nbsp; <a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '7614902', targetLink: 'https://www.cnblogs.com/csguo/p/7614902.html', title: 'java字符串应用之表达式解析器' })">举报</a>
 </div> 
</div> 
<script>
    var cb_entryId = 7614902, cb_entryCreatedDate = '2017-09-30 14:34', cb_postType = 1;
    var allowComments = true, cb_blogId = 370205, cb_blogApp = 'csguo', cb_blogUserGuid = '20e0a68b-fbf8-df11-ac81-842b2b196315';
    mermaidRender.render()
    markdown_highlight()
    zoomManager.apply("#cnblogs_post_body img:not(.code_img_closed):not(.code_img_opened)");
    updatePostStats(
            [cb_entryId],
            function(id, count) { $("#post_view_count").text(count) },
            function(id, count) { $("#post_comment_count").text(count) })
</script> <a id="!comments"></a> 
<div id="blog-comments-placeholder"></div> 
<div id="comment_form" class="commentform"> <a name="commentform"></a> 
 <div id="divCommentShow"></div> 
 <div id="comment_nav">
  <span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a>
 </div> 
 <div id="comment_form_container"></div> 
 <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div> 
 <div id="cnblogs_ch"></div> 
 <div id="opt_under_post"></div> 
 <div id="cnblogs_c1" class="under-post-card"> 
  <div id="div-gpt-ad-1592365906576-0" style="width: 300px; height: 250px;"></div> 
 </div> 
 <div id="under_post_card1"></div> 
 <div id="cnblogs_c2" class="under-post-card"> <a href="https://developer.huawei.com/consumer/cn/forum/topic/0201820468285270027?fid=23&amp;ha_source=bokeyuan" rel="nofollow" target="_blank" onclick="countCreativeClicks('C2-华为专区-HWD2022')"> <img src="img/1647419863921/-5500850601057025575.jpg" alt="" onload="countCreativeImpressions('C2-华为专区-HWD2022')"> </a> 
 </div> 
 <div id="under_post_card2"></div> 
 <div id="HistoryToday" class="under-post-card"></div> 
 <script type="text/javascript">
        var commentManager = new blogCommentManager();
        commentManager.renderComments(0);
        fixPostBody();

                window.tocManager.displayDisableTocTips = false;
                window.tocManager.generateToc();
            setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverT2();
        deliverC1C2();
        loadNewsAndKb();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script> 
</div> </html>
